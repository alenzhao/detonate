I. BUILDING
-----------

To build REF-EVAL, simply run "make" from the current directory. This will
build a single executable (plus a few dependent libraries), ./ref-eval, which
you can run from the current directory or move elsewhere. (The executable is
statically linked with the local dependencies, so you don't need to worry about
the library path.)

If the "make" command fails, you might need to tweak the build process a bit.
To do so, edit ./Makefile and make changes as appropriate to the section marked
"Configuration". Then run "make" again.

REF-EVAL comes with a number of unit tests. To build and run these tests, run
"make test" from the current directory. A C++11-compatible compiler is required
to build some of the tests. To be clear, the tests are mainly useful for
developers, not normal users of the software. It isn't necessary for users to
build or run the tests.



II. RUNNING
-----------

To run REF-EVAL, just run ./ref-eval with appropriate options. Here is an
example:

./ref-eval --scores=nucl,pair \
           --weighted=both \
           --A-seqs test/trinity_default.fa \
           --B-seqs test/cc_0.fa \
           --A-expr test/trinity_default_expression.isoforms.results \
           --B-expr test/cc_0_expression.isoforms.results \
           --A-to-B test/trinity_default_to_cc_0.psl \
           --B-to-A test/cc_0_to_trinity_default.psl \
           --alignment-type psl \
           --readlen 76 \
           | tee scores.txt

Further details are described in the rest of this section. See also ./ref-eval
--help for more information.


II. A. Score specification
--------------------------

First, you need to specify which groups of scores to compute, using the
--scores option, with the values separated by commas (e.g.,
--scores=nucl,contig,kc). It is more efficient to compute all the scores you
are interested in using one invocation of REF-EVAL instead of using multiple
invocations that each compute one score. The available score groups are as
follows:

  Alignment-based score groups:
  - nucl:   nucleotide precision, recall, and F1.
  - contig: contig precision, recall, and F1.
  - pair:   pair precision, recall, and F1.

  Alignment-free score groups:
  - kmer:   kmer Kullback-Leibler divergence,
            Jensen-Shannon divergence, and
            Hellinger distance.
  - kc:     kmer recall, number of nucleotides, and
            kmer compression score.

You also need to specify whether to compute weighted or unweighted variants of
scores. In weighted variants, the expression levels (TPM) of the contigs and
oracleset sequences are taken into account (and hence need to be specified).
Unweighted variants are equivalent to weighted variants with uniform
expression. To specify whether to compute weighted or unweighted variants of
scores, or both, use the --weighted option (e.g., --weighted=yes):

  - yes:  compute weighted variants of scores.
  - no:   compute unweighted variants of scores.
  - both: compute both weighted and unweighted
          variants of scores.

As an alternative to the above, if you are only interested in computing the
scores described in the main text of our paper [1], you can pass the --paper
flag instead of the --scores and --weighted options. In that case, the
following scores will be computed:

  Alignment-based scores:
  - unweighted nucleotide F1
  - unweighted contig F1

  Alignment-free score groups:
  - weighted kmer compression score


II. B. Assembly and oracleset information
-----------------------------------------

You need to specify both the assembly (--A-seqs) and the reference or oracleset
(--B-seqs) to which the assembly is being compared. Both files should be in
FASTA format.

Depending on the scores groups and/or weighted variants you choose to compute,
you may need to specify --A-expr, --B-expr, --A-to-B, and --B-to-A.

The options --A-expr and --B-expr specify the assembly and oracleset
expression, respectively, for use in weighted scores. Their file formats should
match those produced by RSEM in a file called *.isoforms.results.

The options --A-to-B and --B-to-A specify the alignments of the assembly to the
oracleset and vice versa. The file format is specified by --alignment-type; it
can be either --alignment-type=psl or --alignment-type=blast. Currently, BLAST
support is experimental, and you should use the PSL format if possible.

If the flag --strand-specific is present, it is assumed that all the assembly
and oracleset sequences have the same orientation. Thus, alignments or kmer
matches that are to the reverse strand are ignored.


II. C. Miscellaneous parameters
-------------------------------

Several miscellaneous parameters are also of importance. (FIXME: Turn this into
a narrative.)

  --readlen arg                  The read length of the reads used to build the
                                 assembly. Required.
                                 
  --num_reads arg                The number of reads used to build the 
                                 assembly. Required for kc scores.
                                 
  --contig-min-frac-identity arg This option only applies to contig scores. 
                                 Alignments with fraction identity less than 
                                 this threshold are ignored. The fraction 
                                 identity of an alignment is min(x/y, x/z), 
                                 where 
                                 
                                   - x is the number of bases that are 
                                       identical in the assembly sequence and 
                                       the oracleset sequence, according to the
                                       alignment,
                                   - y is the number of bases in the assembly 
                                       sequence, and
                                   - z is the number of bases in the oracleset 
                                       sequence.
                                 
                                 Default: 0.99.
                                 
  --contig-max-frac-indel arg    This option only applies to contig scores. 
                                 Alignments with fraction indel greater than 
                                 this threshold are ignored. For psl 
                                 alignments, the fraction indel of an alignment
                                 is max(w/y, x/z), where 
                                 
                                   - w is the number of bases that are inserted
                                       in the assembly sequence, according to 
                                       the alignment ("Q gap bases"),
                                   - x is the number of bases that are inserted
                                       in the oracleset sequence, according to 
                                       the alignment ("T gap bases"),
                                   - y is the number of bases in the assembly 
                                       sequence, and
                                   - z is the number of bases in the oracleset 
                                       sequence.
                                 
                                 For blast alignments, the fraction indel of an
                                 alignment is max(x/y, x/z), where 
                                 
                                   - x is the number of gaps bases that are 
                                       inserted in the oracleset sequence, 
                                       according to the alignment ("gaps"),
                                   - y is the number of bases in the assembly 
                                       sequence, and
                                   - z is the number of bases in the oracleset 
                                       sequence.
                                 
                                 Default: 0.01.
                                 
  --hash-table-type arg          The type of hash table to use, either "sparse"
                                 or "dense". This is only relevant for kc and 
                                 kmer scores. The sparse table is slower but 
                                 uses less memory. The dense table is faster 
                                 but uses more memory. Default: "sparse".
                                 
  --hash-table-fudge-factor arg  This is only relevant for kc and kmer scores. 
                                 When the hash table is created, its initial 
                                 capacity is set as the total worst-case number
                                 of possible kmers in the assembly and 
                                 oracleset, based on each sequence's length, 
                                 divided by the fudge factor. The default, 2.0,
                                 is often reasonable because (1) most kmers 
                                 should be shared by the assembly and the 
                                 oracleset, and (2) many kmers will be repeated
                                 several times. However, if you have a lot of 
                                 memory or a really bad assembly, you could try
                                 a smaller number. Default: 2.0.

II. D. Output
-------------

REF-EVAL outputs its scores on stdout. Each line of output contains two
tab-separated fields. The first field contains the score's name, and the second
field contains the score's value.

Progress and error messages are printed on stderr.



III. SCORE DEFINITIONS
----------------------

FIXME: Finish this...
